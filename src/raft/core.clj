(ns raft.core
  (:use midje.open-protocols))


(defprotocol IPersist
  (persist [raft] "Persists the essential state of the raft"))


(defrecord-openly Raft [rpc store log current-term this-server servers
                        election-timeout state-machine leader-state voted-for
                        election-timeout-remaining commit-index]
  IPersist
  (persist [raft]
    (let [store (:store raft)]
      (store :log (:log raft))
      (store :current-term (:current-term raft))
      (store :voted-for (:voted-for raft)))
    raft))


(def last-index (comp #(when-not (neg? %) %) dec count :log))

(def last-term (comp :term last :log))


; Calls the external RPC function and blocks on receiving a response.
(defn- call-rpc [raft server command params]
  @(apply (:rpc raft)
          server
          command
          (:current-term raft)
          (:this-server raft)
          (last-index raft)
          (last-term raft)
          params))


; Call the RPC on all servers, passing the provided parameters.
; `params` should be either a list of parameters that are sent
; to all servers, or should be a map from server identifier to
; the list of parameters to send to each server.
; If `params` is a map and a server is ommitted from it, the
; server will not be sent an RPC.
; If the timeout is provided, the operation will abort if it
; takes longer than `timeout` milliseconds.
(defn send-rpc
  ([raft command params timeout]
   (let [get-params (fn [server]
                      (if (map? params)
                        (get params server nil)
                        params))
         rpc (fn [[server params]]
               (call-rpc raft server command params))
         requests (->> raft
                    :servers
                    keys
                    ((juxt identity get-params))
                    (remove #(nil? (second %)))
                    (map agent))]
     (doseq [request requests]
       (set-error-mode! request :contine)
       (set-error-handler! request (fn [ag ex]
                                     ; TODO logging?
                                     (println "rpc failure"  ag ex)))
       (send-off request rpc))
     (if timeout
       (apply await-for timeout requests)
       (apply await requests))
     (map (fn [r] (when-not (agent-error r) @r)) requests)))
  ([raft command params]
   (send-rpc raft command params nil)))



;
; create-raft
;
; `rpc` should be a function (fn [server rpc-name & args] (future result))
; where server is an opaque entry from the servers sequence.
;
; `store` should be a function (fn ([key value] nil) ([key] value))
; that persists the keys and their associated values to a non-volatile
; media. The 1-arity function should return nil if the key is not stored.
; The persistence mechanism should be synchronous.
;
; `state-machine` should be a function (fn [input] [result new-state-machine])
; where input is the command to be executed by the state machine from the log,
; result is the output generated by executing the command, and
; new-state-machine is a function like the original state machine function
; but closed over the new state.
;
; `this-server` should be the server identifier for this server.
;
; `servers` should be a sequence of server identifiers, excluding this
; server.
;
; `election-timeout` is the minimum amount of time (in milliseconds) the server
; will wait before trying to become leader itself during an election.
;
; `election-term` is the election term that the server will start on. It
; defaults to 0.
;
;
(defn create-raft
  [rpc store state-machine this-server servers & {:keys [election-timeout election-term]
                                                  :or {election-timeout 150 election-term 0}}]
  (Raft. rpc store
         (or (store :log) [])
         (or (store :current-term) election-term)
         this-server
         (into {} (mapv #(vector % {}) servers))
         election-timeout
         state-machine
         :follower
         (store :voted-for)
         nil
         nil))
